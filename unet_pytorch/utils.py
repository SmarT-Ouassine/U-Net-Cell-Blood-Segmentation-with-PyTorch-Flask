import torchimport torchvisionfrom dataset import MyDatasetfrom torch.utils.data import DataLoaderimport torch.nn as nnimport torch.nn.functional as Fclass DiceBCELoss(nn.Module):    def __init__(self):        super(DiceBCELoss, self).__init__()    def forward(self, inputs, targets, smooth=1):        # comment out if your model contains a sigmoid or equivalent activation layer        inputs = F.sigmoid(inputs)        # flatten label and prediction tensors        inputs = inputs.view(-1)        targets = targets.view(-1)        intersection = (inputs * targets).sum()        dice_loss = 1 - (2. * intersection + smooth) / (inputs.sum() + targets.sum() + smooth)        BCE = F.binary_cross_entropy_with_logits(inputs, targets, reduction='mean')        Dice_BCE = BCE + dice_loss        return Dice_BCEclass DiceLoss(nn.Module):    def __init__(self):        super(DiceLoss, self).__init__()    def forward(self, inputs, targets, smooth=1):        # comment out if your model contains a sigmoid or equivalent activation layer        inputs = F.sigmoid(inputs)        # flatten label and prediction tensors        inputs = inputs.view(-1)        targets = targets.view(-1)        intersection = (inputs * targets).sum()        dice = (2. * intersection + smooth) / (inputs.sum() + targets.sum() + smooth)        return 1 - dicedef save(state, file="/content/drive/MyDrive/UNET/checkpoint.pth.tar"):    print("==> Saving best weights")    torch.save(state, file)def load(checkpoint, model):    print("==> laoding model")    model.load_state_dict(checkpoint["state_dict"])def get_loaders(train_dir,                train_maskdir,                val_dir,                val_maskdir,                batch_size, train_transform,                val_transform, num_workers,                pin_memory=True):    train_ds = MyDataset(images_dir=train_dir,                         masks_dir=train_maskdir,                         transform=train_transform)    train_loader = DataLoader(train_ds, batch_size=batch_size, num_workers=num_workers,                              pin_memory=pin_memory, shuffle=True)    val_ds = MyDataset(images_dir=val_dir,                         masks_dir=val_maskdir,                         transform=val_transform)    val_loader = DataLoader(val_ds, batch_size=batch_size, num_workers=num_workers,                              pin_memory=pin_memory, shuffle=True)    return train_loader, val_loaderdef score(loader, model, device="cuda"):    num_correct = 0    num_pixels  = 0    dice_score = 0    model.eval()    with torch.no_grad():        for inputs, targets in loader:            inputs = inputs.to(device)            targets = targets.to(device).unsqueeze(1)            inputs = F.sigmoid(model(inputs))            inputs = (inputs > 0.5).float()            num_correct += (inputs == targets).sum()            num_pixels += torch.numel(inputs)            # flatten label and prediction tensors            inputs = inputs.view(-1)            targets = (targets.view(-1))            dice_score += dice_metric(inputs, targets)    print(f"Got {num_correct}/{num_pixels} with acc {num_correct / num_pixels * 100:.2f}")    print(f"Dice score: {dice_score / len(loader)}")    model.train()    return dice_scoredef dice_metric(inputs, target):    intersection = 2.0 * (target * inputs).sum()    union = target.sum() + inputs.sum()    if target.sum() == 0 and inputs.sum() == 0:        return 1.0    return intersection / uniondef save_predictions_as_imgs(    loader, model, folder="saved_images/", device="cuda"):    model.eval()    for idx, (x, y) in enumerate(loader):        x = x.to(device=device)        with torch.no_grad():            preds = torch.sigmoid(model(x))            preds = (preds > 0.5).float()        torchvision.utils.save_image(            preds, f"{folder}/pred_{idx}.png"        )        torchvision.utils.save_image(y.unsqueeze(1), f"{folder}/y_{idx}.png")    model.train()